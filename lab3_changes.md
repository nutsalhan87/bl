# Docker

* Настроен docker compose. В корне лежит [compose.yml](compose.yml).
* Он запускает настроенные postgres, jackrabbit, zookeeper и kafka.
* Запущенные докером программы занимают порты:
  * 9999 - Jackrabbit
  * 9092 - Kafka
  * 5433 - Postgresql
  * 2181 - Zookeeper
* Во всех `applicatoin.properties` указаны необходимые адреса. К тому же изменен порт потсгреса с 5432 на 5433, т.к. он ссылается на экземпляр из докера.

# Изменения

## Видео

* Удалены сущность `Video` и репозиторий `VideoRepository`. Функции репозитория перенесены на отдельный микросервис, который хранит экземпляры видео в Jackrabbit.
* Для работы с видео использовать `VideoService`.
* Как работать с объектами видео:
  * Для общения между клиентом и сервером использовать все так же `VideoDto`.
  * Для общения между узлами сервера использовать новый класс `Video`, который лежит в общей библиотеке.
  * Для хранения связей использовать `Long videoId` вместо `Video video` (т.к. `Video` теперь не сущность).

## Shared

* Создана общая библиотека shared, в которой есть классы `ActionResult`, `Pair` и `Video`.
* Эти классы используются совместно основным узлом и микросервисом для работы с видео.

## Обработка исключений

Теперь вместо десятков классов с исключениями используется один - `ServiceException`. Он инкапсулирует сообщение и код возврата.\
Вместо старых исключений просто созданы фабричные методы в `ServiceException`, которые возвращают исключения с необходимым текстом и кодом возврата.\
Зачем это нужно? В `BlExceptionsHandler` была куча одинакового кода на каждое исключение. Теперь обработчик всего один - на `ServiceException`.

### Пример изменения в коде

Было:
```java
throw new CommentNotFoundException(commentId);
```

Стало:
```java
throw ServiceException.commentNotFound(commentId);
```

# Асинхронная обработка

## Kafka

* Проект использует кафку для асинхронной обработки. 
* Используется модель "подписка".
* Для отправки сообщений используется `KafkaProducer`. Однако по факту используется обертка над ним в виде `KafkaTemplate`, который предоставляется спрингом.
* Для получения сообщений используется `KafkaConsumer`. Однако по факту используется надстройка над ним в виде `KafkaListener`, который предоставляется спрингом.

## Информация для отправки сообщений

В следующем пункте вы изучите, какие методы есть для отправки сообщений.\
Однако через них нельзя напрямую указать, куда отправлять сообщения и что отправлять. Это небезопасно, т.к. любой из программистов
может попросту ошибиться при указании топика или сериализации данных.\
Для того, чтобы не делать это вручную, было принято решение вынести информацию для отправки в отдельный класс - `TopicConversationData`.\
Это фабрика с методами, которые самостоятельно решают, на какой топик слать сообщение для выполнения задачи и как сериализовать данные.\
Класс является финальным, поэтому отнаследоваться со своим топиком и методом сериализации данных не получится. Все должно быть централизованно описано в этом классе.\  
Пример:
```java
Video video = ...;
TopicConversationData conversationData = TopicConversationData.createVideo(video);
send(conversationData); // ну условно
```
Как видно из примера, мы вручную нигде не указываем топик и не сериализуем объект Video. Это происходит при конструировании `TopicConversationData`.

## Отправка сообщений

* Вся отправка сообщений проходит централизованно через компонент `Conversator`.
* Это компонент, значит его можно внедрить. Если вы сконструируете его самостоятельно, то это UB.

Конверсатор поддерживает три вида отправки сообщений:
### Синхронный диалог через метод `Conversator::dialogueSync`.
Вы можете быть уверены, что на момент возврата из функции, программа получит ответ от удаленного узла.
```java
  var result = conversator.dialogueSync(TopicConversationData.findAllVideos())
      .orElseThrow(ServiceException::unexpectedError);
  ```
При успешном результате вернет `Optional.of(body)`. При безуспешном - `Optional.empty()`. Также возвращает пустое значение при таймауте.\
Если никакие данные не ожидаются после отправки на топик (например, при отправке на модифицирующий топик), то\
результат `Optional` можно использовать для того, чтобы понять, прошла ли успешно модификация. Если успешно, то вернет\
`Optional.of("")`.
**ВАЖНО**. Хоть у меня получилось сделать безопасную абстракцию для сериализации отправляемых данных, то\
получать каким образом получать десериализованные объекты разных типов из одной функции я не придумал. Поэтому всегда\
возвращается строка, которую уже вручную с помощью `ObjectMapper` нужно десериализовывать к нужному типу.

### Асинхронный диалог через метод `Conversator::dialogueAsync`.

Нужен строго при написании Saga Action'ов. Об использовании будет написано ниже.

### Монолог через метод `Conversator::monologue`.

Нужен для отправки сообщений, для которых не требуется никакого ответа. Например, когда нам нужно отправить 
предложение для изменения данных, но не требуется подтверждение об успешности изменения.\
Пример. В `VideoController` есть метод `createVideo`, который просто отправляет сообщение создать видео, но не ждет результата этого действия.\
**ВАЖНО**. Из таких эндпоинтов нужно возвращать код 202 Accepted.
    
# Распределенная обработка

## Правила написания кода

* Если никакие данные не модифицируются, то получать данные из репозиториев как есть. Для получения данных от микросервиса
  видео необходимо использовать `Conversator::dialogueSync`.
* Если модифицируются только данные из датасурсов, то это зона ответственности Atomikos. Нужно просто пометить такой метод
  аннотацией `@Transactional`. Для получения данных от микросервиса видео необходимо использовать `Conversator::dialogueSync`.
* Если модифицируются данные только на микросервисе видео, причем единожды (**ВАЖНО**), то нужно использовать:
  * `Conversator::dialogueSync` - если результат важен
  * `Conversator::monologue` - если результат важен
  Микросервис видео написан так, что при неудачной модификации изменения не вносятся, так что в таком случае можно не\
  беспокоиться о компенсации изменений.
* Если модифицируются данные
  * На микросервисе видео больше двух раз
  * И в датасурсах, и на микросервисе видео в рамках одного бизнес-процесса
  
  , то необходимо использовать `SagaOrchestrator`.

## Atomikos

На основном узле могут использовать множество датасурсов. Они не обязаны быть связаны между собой. Главное, что каждый 
из них реализует спецификацию XA. В нашем проекте используется только постгрес, и он реализует XA.\
За такие распределенные транзакции отвечает Atomikos. Под _такими_ транзакциями подразумеваются те, которые модифицируют
данные только в рамках этих датасурсов. Если же модифицируются данные на микросервисе с видео, то Атомикос тут бессилен.
Для распределенной обработки необходимо использовать сагу.

## Saga

### SagaOrchestrator

Это компонент, значит его можно внедрить. Если вы сконструируете его самостоятельно, то это UB.\
В нем есть единственный публичный метод - `SagaOrchestrator::perform(Action[] sagaActions, String initialBody)`.
Он используется для запуска череды модифицирующих действий, каждое из которых может быть скомпенсировано в случае, если
одно из действий завершилось ошибкой.

### SagaOrchestrator.Action

Это класс, представляющий собой этап распределенной обработки.\
Конструктор принимает функцию, которая в свою очередь принимает два аргумента - `Long transactionId` и `String body` -
и возвращает функцию-консьюмер, принимающую `Long transactionId`.\
_Сложно?_ Если проще, то это выглядит так:
```java
new SagaOrchestrator.Action((tid, body) -> {
    // some actions with tid and body
    return t -> { /* some actions with t */ };
});
```

Разберем по частям выше написанное:
* _Зачем принимать `Long tid`?_\
  Это идентификатор транзакции. `Conversator::dialogueAsync` принимает и его, чтобы `SagaOrchestrator` мог
  понять, кому следует передать ответ.
* _Что за `String body`?_\
  Это ответ от предыдущего этапа. Например, в предыдущем этапе мы послали запрос на получение данных с микросервиса видео.
  Значит при этого этапа в body будет лежать ответ от микросервиса видео. К сожалению, десериализовывать придется вручную
  с помощью `ObjectMapper`.
* _Что за функция-консьюмер возвращается?_\
  Это компенсирующее действие. Оно вызовется, если на одном из следующих этапов произойдет ошибка.\
  Функция должна быть противодействием для модифицирущего действия в этом этапе.\
  Пример:
  ```java
  new SagaOrchestrator.Action((tid, body) -> {
    var video = new Video(...);
    videoRepository.save(video);
    return t -> { videoRepository.delete(video); };
  });
  ```
* _А почему ее вообще нужно возвращать, а не, например, передать в этот же конструктор отдельным аргументом?_\
  Потому что компенсирующее действие не обязано быть одинаковым для этапа. Возьмем реальный пример:
  ```java
    new SagaOrchestrator.Action((tid, body) -> {
        var reactionOpt = reactionRepository.findReactionByVideoIdAndAuthorName(videoId, authorName);
        LongConsumer compensator;
        if (reactionOpt.isPresent()) {
            if (reactionOpt.orElseThrow().isPositive() != isPositive) {
                var reaction = reactionOpt.orElseThrow();
                reaction.setPositive(isPositive);
                reactionRepository.save(reaction);
                compensator = t -> {
                    reaction.setPositive(!isPositive);
                    reactionRepository.save(reaction);
                };
            } else {
                compensator = t -> {};
            }
        } else {
            var reaction = new Reaction(null, videoId, authorName, isPositive);
            reactionRepository.save(reaction);
            // ...
            compensator = t -> reactionRepository.delete(reaction);
        }
        conversator.dialogueAsync(tid, TopicConversationData.sagaResponse(new Ok("")));
        return compensator;
    }),
  ```
  Код длинный, однако показательный. На этом этапе сохраняется реакция на видео (лайк, дизлайк). Здесь целых три исхода, 
  как может выглядеть компенсирующее действие:
  * Если ставится реакция, и до этого уже стояла точно такая же, то возвращается компенсирующее действие, которое ничего 
    не делает - `compensator = t -> {};`. Зачем что-то компенсировать, если ничего не изменилось?
  * Если ставится реакция, и до этого уже стояла противоположная, то возвращается компенсирующее действие, которое 
    возвращает реакцию в исходное положение.
  * Если ставится реакция, а до этого ее не стояло вообще, то компенсирующим действием будет полное удаление реакции.
* _А почему в этом примере в конце был вызван `conversator.dialogueAsync(..., <..>sagaResponse(new Ok("")))`?_\
  Так уж устроен компонент, что после выполнения любого этапа он ожидает асинхронное сообщение на специальный топик,
  чтобы приступить к выполнению следующего этапа, если пришло сообщение с `Ok("")`, или выполнить все компенсирующие действия,
  если пришло сообщение с `Fail("")`.\
  Все `TopicConversationData` кроме `TopicConversationData.sagaResponse` по умолчанию отправляют на специальный топик ответ.\
  Однако когда в этапе происходит только модификация датасурсов, то приходится самостоятельно отправлять ответ на топик
  с помощью этой конструкции.
* _А кстати, что за `Ok` и `Fail`?_\
  Это варианты sealed интерфейса `ActionResult` из общей библиотеки. Используются только для ответа на основной узел при
  асинхронной обработке. Собственно, отсюда и берется `body` для `Action`ов. Микросервис видео возвращает `ActionResult`,
  и если это `Ok`, то он содержит строку, которая является телом ответа. Она и передается следующему этапу. Если микросервис
  вернет `Fail`, то это будет означать, что произошла ошибка, и надо запускать компенсирующие действия.

Правила и особенности:
* В рамках этапа должна быть только одна модификация на микросервисе видео. А это `TopicConversationData.viewVideo`, 
  `-updateVideo` и `-deleteVideoById`. Не должно быть ни второй модификации на микросервисе видео, ни модификаций датасурсов.
* Если же происходят модификации датасурсов, то их может быть любое количество раз за этап. Это потому что каждый этап
  выполняется в транзакционном контексте менеджера транзакий (т.е. атомикоса). Если ошибка произойдет в любом
  модифицирующем методе, то выбросится исключение, и все изменения за этап отменятся.\
  Поэтому нельзя модифицировать на микросервисе видео, ведь он вне этого транзакционного контекста.
* Если произошла ошибка, то можете просто пробросить рантайм исключение из этапа вместо того, чтобы посылать через
  `dialogueAsync` `TopicConversationData.sagaResponse` с `Fail("")`, а после пустое компенсирующее действие. Исключение
  будет отловлено, и произойдут ровно эти же действия. Потому нет нужды в таком повторе кода.
* Если этап последний, то можно возвращать компенсирующее действие, которое ничего не делает. Все равно все этапе устроены
  так, что в случае неудачи все действия в этапе будут отменены. Это, конечно, если соблюдать правила написания этапов.
* Если что-то можно прочитать до выполнения этапов, то действительно лучше сделать **до**.
  Например вместо этого:
  ```java
    var actions = new SagaOrchestrator.Action[] {
            new SagaOrchestrator.Action((tid, body) -> {
                conversator.dialogueAsync(tid, TopicConversationData.findVideoById(videoId));
                return t -> {};
            }),
            new SagaOrchestrator.Action((tid, body) -> {
                Video video;
                try {
                    video objectMapper.readValue(body, Video.class);
                } catch (JsonProcessingException e) {
                    throw new RuntimeException(e);
                }
                // сделать что-нибудь с video
            }),
            // ...
        };
  ```
  Лучше написать это:
  ```java
    var video = videoService.findByIdOrThrowNonDto(videoId);
    var actions = new SagaOrchestrator.Action[] {
        new SagaOrchestrator.Action((tid, body) -> {
            // сделать что-нибудь с video
        }),
        // ...
    };
  ```
* Не стесняйтесь использовать переменные за пределами `Action`ов для сохранения промежуточных результатов, которые могут
  понадобиться между этапами (`Action`ами).

Примеры кода можно найти в `VideoReportService::deleteVideo`, `ReactionService::reactVideo`, `ReactionService::unreactVideo`
и `ReactionService::resetReactons`.

# Периодические задачи

В пакете `service` есть пакет `scheduled`. На каждую периодическую задачу в нем необходимо создать класс-конфигурацию.\
В этом классе _минимально_ должны быть описаны:
* Внутренний статический класс, наследующийся от `QuartzJobBean`. В нем должен быть переопределен метод `executeInternal`.\
  Фактически - это действие, которое должно выполняться по расписанию.\
  Если для выполнения действия необходимы какие-нибудь репозитории или сервисы, то их можно внедрить.
* Бин `JobDetail`, который является описанием выполняемой работы. В его билдере необходимо указать класс, описанный шагом выше.
  Делать это нужно с помощью метода `JobDetail::ofType`.
* Бин `Trigger`, который является описанием условий, когда выполняется работа (предыдущий бин).

Писать свои классы-конфигурации для периодических задач можно на примере класса `DeleteOldCommentReports`.